---
title: APT技术之基本使用
tags: 其他
permalink: android-source/dc-other-2
key: android-source-dc-other-2
sidebar:
  nav: android-source
---

## 前言

在上一篇文章中，对注解和反射进行了讲解，如果对注解和反射不太熟悉，建议先去阅读[APT基础之注解与反射](https://qingdian-fan.github.io/android-source/dc-other-1)，至此APT的基础部分已经讲解完毕，接下来就开始APT技术相关的学习了

## APT介绍

### 什么是APT

PT是Annotation Processing Tool（注解处理工具）的缩写。它是一种用于在编译期间处理注解的工具。注解是一种在源代码中加入的特殊标记，用于提供额外的信息给编译器、代码生成器或其他工具使用。

APT可以扫描源代码中的注解，并根据注解的定义生成新的代码。这种代码生成的过程可以根据需要自动化，并且可以根据项目的需求来自定义注解和相应的处理逻辑。

### APT用处

APT在Android开发中广泛应用于生成辅助类、路由框架、依赖注入、序列化等方面（例：ButterKnife、GreenDAO、Room、Arouter等）。它可以帮助开发者减少重复的工作，增强代码的可读性和可维护性，并提升开发效率。

<!--more-->

## 工程介绍

### 一)、结构介绍

一般项目工程分为三个部分：

- app -为主项目module
- lib-annotation - 主要存放编写需要使用的注解（java module）
- lib-processor - 根据lib-annotation中的注解，生成逻辑相关代码（java module）

![other_01_01.png](https://s2.loli.net/2023/09/27/UK14D5N7STCwIWA.png)

### 二）、项目依赖

1. lib-annotation:只是用来存放注解，所以不需要依赖任何
2. Lib-processor: 需要使用lib-annotation中的注解，所以lib-processor需要依赖lib-annotation

```groovy
dependencies {
    implementation project(path: ':lib-annotation')
}
```

3. app为主项目，所以需要以上两个module都需要依赖，注：lib-processor需要使用annotationProcessor，否则不生效

```groovy
dependencies {
    implementation project(path: ':lib-annotation')
    annotationProcessor project(path: ':lib-processor')
}
```

### 三）、lib-annotation注解编写

这个module相对简单，只需要按照需要编写自定义注解就可以，例如

```java
@Retention(RetentionPolicy.CLASS)
@Target(ElementType.FIELD)
public @interface BindView {
    int value();
}
```

### 四）、lib-processor编写

这个module大概分为三个部分

- 注解处理器的声明
- 注解处理器的注册
- 注解处理器生成Java文件

#### 注解处理器的声明

1. 新建一个类，继承AbstractProcessor，并实现相关方法

```
public class DemoProcessor extends AbstractProcessor {

    /**
     * 初始化方法
     * @param processingEnv 这个参数提供了若干工具类，供编写生成 Java 类时所使用
     */
    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
    }

    /**
     * 生成Java 代码文件及逻辑，都在该方法中进行实现
     * @param set   注解集合，TypeElement代表注解元素
     * @param roundEnvironment 通过该对象查找指定注解下的节点信息
     * @return
     */
    @Override
    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {
        return false;
    }

    /**
     * 当前注解器支持注解的集合
     */
    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return super.getSupportedAnnotationTypes();
    }

    /**
     *编译当前注解处理器的 JDK 版本
     */
    @Override
    public SourceVersion getSupportedSourceVersion() {
        return super.getSupportedSourceVersion();
    }
}

```

##### Element介绍

Java文件每一部分都对应着一种Element，例：

    package com.dream;         // PackageElement：包元素
    
    public class Main<T> {     // TypeElement：类元素; 其中 <T> 属于 TypeParameterElement 泛型元素
    
        private int x;         // VariableElement：变量、枚举、方法参数元素
    
        public Main() {        // ExecutableElement：构造函数、方法元素
        }
    }
Element实际是一个接口，具体源码如下

```
public interface Element extends AnnotatedConstruct {
    TypeMirror asType(); // 元素的类型

    ElementKind getKind();//Element的类型

    Set<Modifier> getModifiers();//获取修饰符

    Name getSimpleName();//获取类名

    Element getEnclosingElement();//获取包含该节点的父节点

    List<? extends Element> getEnclosedElements();//获取该节点包含的子节点

    boolean equals(Object var1);

    int hashCode();

    List<? extends AnnotationMirror> getAnnotationMirrors();

    <A extends Annotation> A getAnnotation(Class<A> var1);//获取注解

    <R, P> R accept(ElementVisitor<R, P> var1, P var2);
}
```

Element大致分为五类

- PackageElement 表示一个包程序元素

- TypeElement 表示一个类或者接口程序元素

- TypeParameterElement 表示一个泛型元素

- VariableElement 表示一个字段、enum 常量、方法或者构造方法的参数、局部变量或异常参数

- ExecutableElement 表示某个类或者接口的方法、构造方法或初始化程序（静态或者实例）

#### 注解处理器的注册

1. 我们需要在lib-processor下导入相关依赖

```
dependencies {
    implementation 'com.google.auto.service:auto-service:1.0-rc6'
    annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'
}
```

1. 在我们需要在刚刚定义的`DemoProcessor`类上面加上`@AutoService(Processor.class)`注解，就可以了，剩下会在编译时自动注册

#### 注解处理器生成Java文件



## 总结









