---
title: AspectJ基本使用
tags: 其他
permalink: android-source/dc-other-4
key: android-source-dc-other-4
sidebar:
  nav: android-source
---

## 一、AOP介绍

AOP：Aspect-Oriented Programming，面向切面编程，是一种新的方法论（编程范式），是对传统 OOP(Object-Oriented Programming，面向对象编程)的补充。旨在通过允许横切关注点的分离，提高模块化。如在方法执行前、或执行后、或是在执行中出现异常后这些地方进行拦截处理或叫做增强处理。主要应用于：日志收集、事务管理、安全检查、缓存、对象池管理等。

AOP实现的关键就在于AOP框架自动创建的AOP代理，AOP代理则可分为静态代理（例如：原生AspectJ）和动态代理（例如：spring aop）两大类，其中静态代理是指使用AOP框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；而动态代理则在运行时借助于JDK动态代理、CGLIB等在内存中“临时”生成AOP动态代理类，因此也被称为运行时增强。

### AOP基本概念：

切入点（pointcut）：在哪些类、哪些方法上切入，通常是一个正则表达式
执行点（JoinPoint）：通过pointcut选取出来的集合中的具体的一个执行点，我们就叫JoinPoint
通知（advice）：在方法前、方法后、方法前后、异常等做什么。
切面（aspect）：切面 = pointcut + advice。即在什么时机、什么地方、做什么。
织入（weaving）：把切面加入对象，并创建出代理对象的过程。

<!--more-->

## 二、AspectJ介绍

AspectJ：全称Eclipse AspectJ，官网The AspectJ Project | The Eclipse Foundation 是Java社区里最完整最流行的AOP框架，即AOP的java版实现，它定义了AOP语法，它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。（除了AspectJ外，还有很多AOP实现，例如ASMDex）



在项目的build.gradle中添加一下代码

```groovy
classpath 'org.aspectj:aspectjtools:1.9.6'
classpath 'org.aspectj:aspectjweaver:1.9.6'

```

在module的build.gradle中添加一下代码

```
implementation 'org.aspectj:aspectjrt:1.9.6'
```



```
//aop aspectj
import org.aspectj.bridge.IMessage
import org.aspectj.bridge.MessageHandler
import org.aspectj.tools.ajc.Main

android.applicationVariants.all { variant ->

        def fullName = ""
        output.name.tokenize('-').eachWithIndex { token, index ->
            fullName = fullName + (index == 0 ? token : token.capitalize())
        }

        JavaCompile javaCompile = variant.javaCompiler

        MessageHandler handler = new MessageHandler(true)
        javaCompile.doLast {
            String[] javaArgs = ["-showWeaveInfo",
                                 "-1.8",
                                 "-inpath", javaCompile.destinationDir.toString(),
                                 "-aspectpath", javaCompile.classpath.asPath,
                                 "-d", javaCompile.destinationDir.toString(),
                                 "-classpath", javaCompile.classpath.asPath,
                                 "-bootclasspath", project.android.bootClasspath.join(
                    File.pathSeparator)]

            String[] kotlinArgs = ["-showWeaveInfo",
                                   "-1.8",
                                   "-inpath", project.buildDir.path + "/tmp/kotlin-classes/" + fullName,
                                   "-aspectpath", javaCompile.classpath.asPath,
                                   "-d", project.buildDir.path + "/tmp/kotlin-classes/" + fullName,
                                   "-classpath", javaCompile.classpath.asPath,
                                   "-bootclasspath", project.android.bootClasspath.join(
                    File.pathSeparator)]

            new Main().run(javaArgs, handler)
            new Main().run(kotlinArgs, handler)

            def log = project.logger
            for (IMessage message : handler.getMessages(null, true)) {
                switch (message.getKind()) {
                    case IMessage.ABORT:
                    case IMessage.ERROR:
                    case IMessage.FAIL:
                        log.error message.message, message.thrown
                        break
                    case IMessage.WARNING:
                    case IMessage.INFO:
                        log.info message.message, message.thrown
                        break
                    case IMessage.DEBUG:
                        log.debug message.message, message.thrown
                        break
                }
            }
        }
    }

}
```





定义一个注解

```
@Retention(AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.FUNCTION)
annotation class SingleClick constructor(
    /**
     * 快速点击的间隔
     */
    val value: Long = 800
)
```



实现Aspect

```

/**
 * 如果这个文件是 java文件则只有java代码会生效
 * 如果是kotlin文件则java和kotlin代码都会生效
 */
@Aspect
class SingleClickAspect {
    /**
     * 定义切点，标记切点为所有被@SingleClick注解的方法
     * 自己项目中SingleClick这个类的全路径哦
     */
    @Pointcut("execution(@com.demo.aspectj.SingleClick * *(..))")
    fun methodAnnotated() {
    }

    /**
     * 定义一个切面方法，包裹切点方法
     */
    @Around("methodAnnotated()")
    @Throws(Throwable::class)
    fun aroundJoinPoint(joinPoint: ProceedingJoinPoint) {
        // 取出方法的参数
        var view: View? = null
        for (arg in joinPoint.args) {
            if (arg is View) {
                view = arg
                break
            }
        }
        if (view == null) {
            return
        }
        // 取出方法的注解
        val methodSignature = joinPoint.signature as MethodSignature
        val method = methodSignature.method
        if (method == null || !method.isAnnotationPresent(SingleClick::class.java)) {
            return
        }
        val singleClick = method.getAnnotation(SingleClick::class.java)
        // 判断是否快速点击
        if (!isFastClick()) {
            // 不是快速点击，执行原方法
            joinPoint.proceed()
        }
    }
}
```



代码中调用样例

```
var index = 0

@SingleClick
fun onClick(view: View) {
    index++
   (view as TextView).text = "点击：$index"
}
```



代码地址：[Aspectj基本使用](https://github.com/QingDian-Fan/ArchitectureProjects/tree/master/AspectjProject)
