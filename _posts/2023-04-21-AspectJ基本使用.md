---
title: AspectJ基本使用
tags: 其他
permalink: android-source/dc-other-4
key: android-source-dc-other-4
sidebar:
  nav: android-source
---

## 一、AOP介绍

AOP：Aspect-Oriented Programming，面向切面编程，是一种新的方法论（编程范式），是对传统 OOP(Object-Oriented Programming，面向对象编程)的补充。旨在通过允许横切关注点的分离，提高模块化。如在方法执行前、或执行后、或是在执行中出现异常后这些地方进行拦截处理或叫做增强处理。主要应用于：日志收集、事务管理、安全检查、缓存、对象池管理等。

AOP实现的关键就在于AOP框架自动创建的AOP代理，AOP代理则可分为静态代理（例如：原生AspectJ）和动态代理（例如：spring aop）两大类，其中静态代理是指使用AOP框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；而动态代理则在运行时借助于JDK动态代理、CGLIB等在内存中“临时”生成AOP动态代理类，因此也被称为运行时增强。

### AOP基本概念：

切入点（pointcut）：在哪些类、哪些方法上切入，通常是一个正则表达式
执行点（JoinPoint）：通过pointcut选取出来的集合中的具体的一个执行点，我们就叫JoinPoint
通知（advice）：在方法前、方法后、方法前后、异常等做什么。
切面（aspect）：切面 = pointcut + advice。即在什么时机、什么地方、做什么。
织入（weaving）：把切面加入对象，并创建出代理对象的过程。

<!--more-->

## 二、AspectJ介绍

AspectJ：全称Eclipse AspectJ，官网The AspectJ Project | The Eclipse Foundation 是Java社区里最完整最流行的AOP框架，即AOP的java版实现，它定义了AOP语法，它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。（除了AspectJ外，还有很多AOP实现，例如ASMDex）

```groovy
implementation 'org.aspectj:aspectjrt:1.9.6'
```



```
classpath 'org.aspectj:aspectjtools:1.9.6'
classpath 'org.aspectj:aspectjweaver:1.9.6'
```



```
//aop aspectj
import org.aspectj.bridge.IMessage
import org.aspectj.bridge.MessageHandler
import org.aspectj.tools.ajc.Main

android.applicationVariants.all { variant ->

    variant.outputs.all { output ->
        def buildTime = project.hasProperty('BUILD_TIME') ? BUILD_TIME : new Date().format("yyyyMMdd", TimeZone.getTimeZone("GMT+08:00"))

        def newPath = outputFileName.replace(".apk", "-${variant.versionName}-${buildTime}.apk")
        outputFileName = new File("玩Android", newPath)

        def fullName = ""
        output.name.tokenize('-').eachWithIndex { token, index ->
            fullName = fullName + (index == 0 ? token : token.capitalize())
        }

        JavaCompile javaCompile = variant.javaCompiler

        MessageHandler handler = new MessageHandler(true)
        javaCompile.doLast {
            String[] javaArgs = ["-showWeaveInfo",
                                 "-1.8",
                                 "-inpath", javaCompile.destinationDir.toString(),
                                 "-aspectpath", javaCompile.classpath.asPath,
                                 "-d", javaCompile.destinationDir.toString(),
                                 "-classpath", javaCompile.classpath.asPath,
                                 "-bootclasspath", project.android.bootClasspath.join(
                    File.pathSeparator)]

            String[] kotlinArgs = ["-showWeaveInfo",
                                   "-1.8",
                                   "-inpath", project.buildDir.path + "/tmp/kotlin-classes/" + fullName,
                                   "-aspectpath", javaCompile.classpath.asPath,
                                   "-d", project.buildDir.path + "/tmp/kotlin-classes/" + fullName,
                                   "-classpath", javaCompile.classpath.asPath,
                                   "-bootclasspath", project.android.bootClasspath.join(
                    File.pathSeparator)]

            new Main().run(javaArgs, handler)
            new Main().run(kotlinArgs, handler)

            def log = project.logger
            for (IMessage message : handler.getMessages(null, true)) {
                switch (message.getKind()) {
                    case IMessage.ABORT:
                    case IMessage.ERROR:
                    case IMessage.FAIL:
                        log.error message.message, message.thrown
                        break
                    case IMessage.WARNING:
                    case IMessage.INFO:
                        log.info message.message, message.thrown
                        break
                    case IMessage.DEBUG:
                        log.debug message.message, message.thrown
                        break
                }
            }
        }
    }

}
```





```
@Retention(AnnotationRetention.RUNTIME)
@Target(
    AnnotationTarget.FUNCTION,
    AnnotationTarget.PROPERTY_GETTER,
    AnnotationTarget.PROPERTY_SETTER
)
annotation class CheckPermissions constructor(
    /**
     * 需要申请权限的集合
     */
    vararg  val value: String,
    val isMust:Boolean = false
)
```





```
@Aspect
class CheckPermissionsAspect {

    @Pointcut("execution(@com.dian.demo.utils.aop.CheckPermissions * *(..))")
    fun methodPermissions() {

    }

    @Around("methodPermissions()")
    @Throws(Throwable::class)
    fun aroundJoinPermissions(joinPoint: ProceedingJoinPoint) {
        LogUtil.e("TAGTAG", "AOP-CheckPermissions")
        var mActivity: AppCompatActivity? = null
        for (arg in joinPoint.args) {
            if (arg is AppCompatActivity) {
                mActivity = arg
                break
            }
        }
        if ((mActivity == null) || mActivity.isFinishing || mActivity.isDestroyed) {
            LogUtil.e("TAGTAG", "AOP-CheckPermissions-mActivity is null")
            mActivity = ActivityManager.getInstance().getTopActivity() as AppCompatActivity
        }
        val methodSignature = joinPoint.signature as MethodSignature
        val method = methodSignature.method
        if (method === null || !method.isAnnotationPresent(CheckPermissions::class.java)) {
            return
        }
        val checkPermissions = method.getAnnotation(CheckPermissions::class.java)
        val permissionList: Array<out String> = checkPermissions?.value ?: arrayOf()
        val isMustPermission = checkPermissions?.isMust
        LogUtil.e("TAGTAG", "AOP-CheckPermissions-do it")
        if (PermissionsUtil.hasAopPermission(mActivity, permissionList)) {
            joinPoint.proceed()
        } else {
            requestPermissions(joinPoint, mActivity, permissionList, isMustPermission ?: false)
        }
    }

    private fun requestPermissions(
        joinPoint: ProceedingJoinPoint,
        mActivity: AppCompatActivity,
        permissions: Array<out String>,
        isMustPermission: Boolean
    ) {
        LivePermissions(mActivity).requestArray(permissions)
            .observe(mActivity) {
                when (it) {
                    is PermissionResult.Grant -> {  //权限允许
                        joinPoint.proceed()
                    }
                    is PermissionResult.Rationale -> {  //权限拒绝
                        if (isMustPermission) {
                            val dialog = TipDialog.getDialog("提示", "请到设置中打开权限，否则无法使用该功能")
                            dialog.showAllowStateLoss(mActivity.supportFragmentManager, "")
                        } else {
                            joinPoint.proceed()
                        }
                    }
                    is PermissionResult.Deny -> {   //权限拒绝，且勾选了不再询问
                        if (isMustPermission) {
                            val dialog = ConfirmDialog.getDialog(
                                "提示",
                                "请到设置中打开权限，否则无法使用该功能",
                                "dian://setting"
                            )
                            dialog.showAllowStateLoss(mActivity.supportFragmentManager, "")
                        } else {
                            joinPoint.proceed()
                        }
                    }
                }
            }
    }
}
```





```
@CheckPermissions(
    Manifest.permission.CAMERA,
    Manifest.permission.READ_EXTERNAL_STORAGE,
    Manifest.permission.WRITE_EXTERNAL_STORAGE,
    isMust = false
)
fun toPage() {
    getTitleBarView().postDelayed({
        HomeActivity.start(this@SplashActivity)
        finish()
    }, 500)
}
```

代码地址：[Aspectj基本使用](https://github.com/QingDian-Fan/ArchitectureProjects/tree/master/AspectjProject)
